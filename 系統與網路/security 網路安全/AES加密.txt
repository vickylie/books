AES加密

       NIST(國家標準技術局)於1977年所公佈的加密法DES,直至目前,以因目
  前積體電路設計的蓬勃發展,具備高速運算能力的電腦到處都是.在這種情形
  之下,金鑰長度只有56位元的DES安全性以不足以抵擋為其專門設計的破解攻
  擊.有鑑於此,NIST於1997年開始公開徵求下一代演算法AES(Advanced --
  Encryption Standard)以用於取代DES.經歷4年左右的的評估之後,在2000年
  10月2日,Rijndael終於從最後5個候選演算法中獲選而出,獲選為AES加密演算
  法.
       Rijndael是由兩位比利時的密碼學家Jean Daemen 及 Vincent Rijmen
  所提出的,命名是採用兩位作者的名子,不過顯然不太好唸:P,基本上,Rijmen
  是一個多回合運算的區塊加密法(Black Cipher),既加密前的資料長度跟加密
  後的資料長度是一樣的,為了適應不同的需求,它可以支援變動的資料區塊以
  及金鑰長度,加密以後的執行回合數(Nr)是根據資料區塊及金鑰長度來決定的
  ,其資料區塊長度、金鑰長度及回合數(Nr)的關係表如下

|----------------------------------------------------------
|\資料區塊長度 |             |              |
|\ ~~~~~~\     |             |              |
|金\回合  \    |  128位元    |    192位元   |   256位元
|鑰長\ 數  \   |             |              |
|度   \     \  |             |              |
|-----------------------------------------------------------
|128位元       |     10      |      12      |    14
|-----------------------------------------------------------
|192位元       |     12      |      12      |    14
|-----------------------------------------------------------
|256位元       |     14      |      14      |    14
|-----------------------------------------------------------

圖畫的差了點....別太介意....

這幾個名詞文後會提到,請數我先說明其意義

1)State
        在運算中資料暫存的狀態,4*Nb的矩陣,Nb可由資料區塊長度除以32得 
  之,例如 : 資料區塊長度為192位元時,Nb=192/32=6.其中,資料存放時,是以
  行為主的順序存入矩陣裡.
2)Cipher Key
        用來參予加密的金鑰,其長度可為128 192 256位元,4*Nb的矩陣表示
  之,其中Nk可由金鑰長度除以32而得,例如:金鑰長度為128時,Nb=128/32=4 
  其中,金鑰表示時也是以行為主的順序放入矩陣中.
3)Round Key
        參與各回合運算ˋ的回合金鑰，Cipher Key變化而成的.詳細的金鑰生
成步驟惠在後面進一部介紹.

Rijndael演算法架構及加密過程

B:ByteSub(State)                                    CipherKey =====> KeyExpansion
S:ShiftRow(State)                           明文                          │
M:MixColumn(State)                           ↓                           ↓
A:AddRoudnKey(State,RouteKey)            AddRouteKey()   <=========   RoundKey 0
                                             ↓
       Round 1     ----------------------  B S M A   <================RoundKey 1
          |                                  ↓                              |
     第Nr-1回合    ----------------------  B S M A   
                                             ↓          
      第Nr回合   ------------------------   B S A  <================= RoundKey Nr
                                             ↓
                                            密文
        如上圖所示,Rijdndael演算法是一個多回合運算架構,欲加密的資料區塊一開始經過
  AddRoundKey這回合的運算之後,在經過Nr個回合的反覆運算既可完成加密過程.由圖中可知
  道,每回合都會有一把回合金鑰RoundKey一起運算.
        Rijdndael每回合主要包含四個子運算,分別是位元組取代轉換(ByteSub  ----
  Transformation)、移列轉換(ShiftRow Transformation)、混行轉換(MixColumn  ----
  Transformation)及與Round Key 作互斥或(XOR)運算 (AddRoundKey)但是最後一回合比較特
  殊,只有三個子運算,少了混行轉換這組運算.
       
 1~位元存取轉換 (ByteSub Transformation)
     這組運算相當類似DES中的S-BOX功能,他會將State中的各個位元組作非線性的取代運算,
  其取代表(S-BOX)的建立過程如下:
     1)找出各個位元組在GF(2^8)中的乘法反元素
     2)將求得的值經過下列的仿射轉換 (Affine Transformation)運算既可得到取代值.

|y0|       |1 0 0 0 1 1 1 1| |x0|    |1|
|y1|       |1 1 0 0 0 1 1 1| |x1|    |1|
|y2|       |1 1 1 0 0 0 1 1| |x2|    |0|
|y3|       |1 1 1 1 0 0 0 1| |x3|    |0|
|y4|    =  |1 1 1 1 1 0 0 0| |x4|  + |0|  
|y5|       |0 1 1 1 1 1 0 0| |x5|    |1|
|y6|       |0 0 1 1 1 1 1 0| |x6|    |1|
|y7|       |0 0 0 1 1 1 1 1| |x7|    |0| 

下面就是當資料區塊長度為192位元(Nb=6)時,經過位元取代後的新State.
   0   4   8 123 128 123     99 242  48 ...  ... ...
   1  15 150 124 164  15 → 124 118  45 ...  ... ...
 255   6  10 233  24 255 →  22 111 103 ...  ... ...
   3   7  11  54  67  34    123 197  43 ...  ... ...


  2~移列轉換 (ShiftRow Transformation)
        這個轉換會把State內的資料作環狀位移,環狀位移的規則是:第0列的資料不動,第一
  列的資料向左位移C1個位元組,第二列的資料想佐位移c2個位元組,第三列的想佐位移C3個位元
  組.其中偏移量C1,C2,C3是依據資料區塊長度而定,定義如下:

資料長度(位元)   C1   C2   C3
  128             1    2    3
  192             1    2    3
  256             1    3    4

下面的例子是當資料區塊長度為192位元時...State經過一列轉換過的結果
   99 242  48 .. .. ..    99 242 48  ..  ..  ..
  124 118  45 .. .. .. →118  45 ..  ..  .. 124
   22 111 103 .. .. .. →103  .. ..  ..  22 111
  123 197  43 .. .. ..    ..  .. .. 123 197  43

  3~混行轉換(MixColumn Transformation)
        這個運算慧將State內的每一行當作一個存在於GF(2^8)中的多項式,並將多項是跟令一
  多項式c(x)在模(x^4)+1中作乘法運算,其中:
                c(x)='03'X3+'01'X^2+'01'X+'02'
  因此,若令a(x)=a3(x^2)+a2(X^2)+a1+a0表State內某一行資料所代表的多項式, 
  b(x)= b3(x^3) + b2(x^2) + b1x + bx0 代表c(x)跟a(x)在模(X^4)+1作乘法運ˋ算之後的結
  果,則:

   b0 = '02' ˙ a0 ♁ '03' ˙a1 ♁'01' ˙ a2 ♁ '01' ˙a3
   b1 = '01' ˙ a0 ♁ '02' ˙a1 ♁'03' ˙ a2 ♁ '01' ˙a3
   b2 = '01' ˙ a0 ♁ '01' ˙a1 ♁'02' ˙ a2 ♁ '03' ˙a3
   b3 = '03' ˙ a0 ♁ '01' ˙a1 ♁'01' ˙ a2 ♁ '02' ˙a3
     
   此處'♁'表示互斥或(XOR)運算.所以,整個運算過程譯可用於矩陣乘法表示成B(x)=c(x)♁a(x)

   b(x)           c(x)     a(x) 
   |b0|      |02 03 01 01 ||a0|
   |b1|   =  |01 02 03 01 ||a1|
   |b2|      |01 01 02 03 ||a2|
   |b3|      |03 01 01 02 ||a3|

   State 在經過混行轉換之後會產生如下的變化:
             /------->♁c(x)<----------------\ 
            /                                 \
a0.0 a0.1 a0.2 a0.3 a0.4 a0.5      b0.0 b0.1 b0.2 b0.3 b0.4 b0.5
a1.0 a1.1 a1.2 a1.3 a1.4 a1.5      b1.0 b1.1 b1.2 b1.3 b1.4 b1.5
a2.0 a2.1 a2.2 a2.3 a2.4 a2.5      b2.0 b2.1 b2.2 b2.3 b2.4 b2.5
a3.0 a3.1 a3.2 a3.3 a3.4 a3.5      b3.0 b3.1 b3.2 b3.3 b3.4 b3.5

 
       金鑰產生過程
     Rijndael各回合的加密運算慧有一把回合金鑰(RoundKey)參予運算,因此,在整個加密過程中,我
  們總共慧用到Nr+1把回合金鑰,接下來的單雲辨識介紹如何由加密金鑰(Cipher Key)產生這Nr+1把回
  合金鑰.
     回合金鑰的產生是由金鑰擴充(Key Expansion)以及回合金鑰選擇(Round Key Seletction)這兩
  步驟完成的,金鑰擴充會將加密金鑰擴充至Nr+1把回合所需的長度,長度計算的方法如下:
       (Nr+1 把回合金鑰總長度) = (資料區塊長度) * (Nr+1) 位元
     例如:128位元的資料區塊,欲由192位元的加密金鑰進行加密時,總需要12回合(Nr+12)的運算,所
  以需要的回合金鑰總長度為128*(12+1)=1664位元.
     擴充後的金鑰被儲存放在一個4-byte的線性陣列 W[Nb*(Nr+1)]中,回合金鑰選擇時的規則式,第一
  回合的回合金鑰既為此陣列中的前Nr個字組,第二回合的回合金鑰則由接下來的Nb個字組所組成,其餘
  依此類推.

金鑰擴充 (Key Expansion)
        金鑰擴充方式跟加密金鑰的長度有著密不可分的關係.當家密金鑰的長度為128位元Nk=4及192
  位元(Nk=6)時勢一種運作方式,256位元(Nk=8)時又是另一種擴充方式.擴充時的演算法如下:
      1.當Nk<=6
        步驟一 將加密金鑰複製到陣列W[0..Nk-1]中
        步驟二 
           for i:=Nk to Nb*Nk do {
              temp =W[i-1];
               if (i%Nk==0) 
                  temp = SubByte(RotByte(temp)) ♁ Rcon[i/Nk];
              W[i]=W[i-Nk] ♁ temp;}
      2.當Nr=8時
        步驟一 將加密金鑰複製到陣列W[0..Nk-1]中
        步驟二 
           for i:=Nk to Nb*Nr do {
               temp=W[i-1];
               
               if (i%Nk==0)
                  temp= SubByte (RotByte (temp)) ♁ Rcon[i/Nk];
               else 
                  if (i%Nk==4)
                      temp =SubByte (temp);
                  W[i]=W[i-Nk] ♁ temp;}
     在以上的金鑰擴充演算式中,
   RotByte(W[i])副程式會傳迴旋轉過的字組,旋轉方式.(a,b,c,d)→(b,c,d,a)
   SubByte(W[i])這支付程式會傳回W[i]經過S-Box轉換過的值
   常數Rcon[i] = (RC[i], 'OO', 'OO','OO'),其中RC[i]=x^(i-1)表GF(2^8)中的一個值

  金鑰選擇
      第一回合運算時所需的金鑰既為線性陣列W中的第Nb*i中的第Nb*(i+1)個元素.以資
  料區塊長度為192位元(Nb=6)時為例,各回合金鑰選擇如以下

W0    W1  W2  W3  W4  W5  W6  W7  W8  W9  W10  W11  W12  W13  W14  ...
32bit                  │ │                    │
└--->Round Key 0  <===┘  \----Round Key 1 ----/

結論
    從實作上的觀點來看,Rijndael 的設計十分簡單 ,並沒有複雜的算數計算.因此在計算
  能力不情的smart card也能實作出來.另外,本身設計十分明確.不容易藏後門
    另外,在DES中,有存在著幾個特別的金鑰.若使用者不慎使用這些金鑰,DES的安全將會大
  大降低.我們將這種金鑰稱之為弱金鑰.而這些弱金鑰產生的原因是因為DES產生子金鑰過
  程設計不當所導致,相對的,Rijndael加密法的非線性運算完全定義在取代表中,金鑰只是
  用來作互斥或(xor)的運算而已.因此金鑰值跟整個加密法的非線性運算不會有太大關聯,
  所以在Rijndael中不會因為金鑰選擇不當而產生弱點,也不存在若金鑰的問題